---
name: tla-symbols
description: Extract symbols from TLA+ spec and generate TLC configuration
argument-hint: "@spec.tla [--extended]"
allowed-tools: [Read, Write, Bash, Grep]
---

# Extract Symbols and Generate Config

Extract symbols (constants, variables, operators) from TLA+ specification and generate a TLC configuration file.

## Usage

```
/tla-symbols @Counter.tla
/tla-symbols @Spec.tla --extended
/tla-symbols path/to/Module.tla
```

## Arguments

- **spec.tla** (required) - TLA+ specification file
- **--extended** (optional) - Include symbols from extended/instantiated modules

## What This Command Does

1. Parses specification with SANY
2. Extracts symbols using `tlaplus_mcp_sany_symbol`
3. Identifies constants, variables, init, next, spec
4. Makes best-guess for invariants and properties
5. Displays symbol analysis
6. Offers to generate .cfg file with suggestions

## Symbol Extraction

### Candidates Found

The tool identifies:
- **Constants** - Declared with CONSTANT
- **Variables** - Declared with VARIABLES
- **State Predicates** - Level 1 operators (for Init)
- **Action Predicates** - Level 2 operators (for Next)
- **Temporal Formulas** - Level 3 operators (for Spec)
- **Operators with Args** - User-defined operators
- **Theorems** - Proved properties
- **Assumptions** - ASSUME statements

### Best Guess Recommendations

Uses naming heuristics to suggest:
- **Init**: Looks for "Init", "Initial", "InitState" (exact or prefix match)
- **Next**: Looks for "Next", "NextState", "Step"
- **Spec**: Looks for "Spec", "Specification", "Temporal"
- **Invariants**: Operators containing "Inv", "TypeOK", "Correct"
- **Properties**: Temporal formulas with "Liveness", "Property"

### Module Preference

When multiple matches found:
1. **Root module** (highest priority) - Symbols defined in main spec
2. **Extended modules** (medium) - From extended non-stdlib modules
3. **Standard library** (lowest) - Fallback only

## Output Format

### Symbol Table
```
=== Symbol Analysis for Counter.tla ===

Constants:
  - MaxValue (line 5)

Variables:
  - count (line 8)

State Predicates (Level 1):
  - Init (line 11) [EXACT MATCH for Init]
  - TypeInvariant (line 27)
  - BoundInvariant (line 30)

Action Predicates (Level 2):
  - Increment (line 14)
  - ReachMax (line 18)
  - Next (line 22) [EXACT MATCH for Next]

Temporal Formulas (Level 3):
  - Spec (line 25) [EXACT MATCH for Spec]

Best Guess Configuration:
  INIT: Init (exact match, root module)
  NEXT: Next (exact match, root module)
  SPEC: Spec (exact match, root module)
  INVARIANTS: TypeInvariant, BoundInvariant
  PROPERTIES: (none found)
```

### Generated Config
```
Generate Counter.cfg? (y/n)
```

If yes, creates:
```
\* TLC Configuration for Counter
\* Generated by /tla-symbols

\* Constants - Provide values for declared constants
CONSTANT
    MaxValue = 10

\* Specification - Which formula to check
SPECIFICATION Spec

\* Alternatively, specify Init and Next separately:
\* INIT Init
\* NEXT Next

\* Invariants - Properties that must hold in all states
INVARIANT
    TypeInvariant
    BoundInvariant

\* Properties - Temporal properties to verify
\* PROPERTY LivenessProperty

\* State constraints - Limit state space exploration (optional)
\* CONSTRAINT count <= 100
```

## Match Quality Indicators

- **exact** - Exact name match (e.g., "Init")
- **case_insensitive_exact** - Case differs (e.g., "init")
- **prefix** - Name starts with pattern (e.g., "InitState")
- **contains** - Name contains pattern (e.g., "MyTypeInvariant")
- **fallback_first_candidate** - No match, using first available

## When to Use

### New Specifications
After writing a spec, before model checking:
```
1. Write Counter.tla
2. /tla-symbols @Counter.tla
3. Review and customize generated Counter.cfg
4. /tla-check @Counter.tla
```

### Missing Config
When `/tla-check` reports missing config:
```
Error: No Counter.cfg found
→ Run /tla-symbols @Counter.tla
```

### Spec Refactoring
After renaming operators, regenerate config:
```
1. Rename Init → Initialize
2. /tla-symbols @Spec.tla
3. Update config with new names
```

### Understanding Symbols
To explore what's defined in a spec:
```
/tla-symbols @UnknownSpec.tla
```
See all operators and their types.

## Configuration Customization

After generation, customize the .cfg file:

### Set Constants
```
CONSTANT
    MaxValue = 10
    NumProcesses = 3
    MaxMessages = 5
```

### Choose Spec Style
Option 1 - Use Spec formula:
```
SPECIFICATION Spec
```

Option 2 - Separate Init/Next:
```
INIT Init
NEXT Next
```

### Add Invariants
```
INVARIANT
    TypeInvariant
    SafetyProperty
    CustomInvariant
```

### Add Properties
```
PROPERTY
    EventuallyCompletes
    AlwaysResponds
```

### Constrain State Space
```
CONSTRAINT
    count <= 1000
    queueSize <= 50
```

## Tips

### Review Before Using
Generated config is a starting point. Always review:
- Constant values (use small values initially)
- Selected invariants (add custom ones)
- Temporal properties (may need fairness)

### Incremental Checking
Start with:
1. Type invariants only
2. Add safety invariants
3. Add temporal properties
4. Add fairness conditions

### Multiple Configs
Create specialized configs:
```
Counter-Small.cfg    (MaxValue = 5)
Counter-Medium.cfg   (MaxValue = 50)
Counter-Large.cfg    (MaxValue = 500)
```

### Extended Modules
Use `--extended` to include symbols from imported modules:
```
/tla-symbols @Spec.tla --extended
```
Useful for multi-module specifications.

## Related Commands

- `/tla-parse` - Parse before extracting symbols
- `/tla-check` - Use generated config for model checking
- `/tla-review` - Review full specification structure

## Related Skills

- `tla-model-checking` - Complete configuration guide
- `tla-getting-started` - Learn about TLC configs

## Implementation

Call MCP symbol extraction:

```javascript
tlaplus_mcp_sany_symbol({
  fileName: absolutePath,
  includeExtendedModules: extendedFlag
})
```

Parse response (schemaVersion: 1):
- Extract candidates by category
- Apply best-guess heuristics
- Format symbol table
- Generate config template with comments
- Offer to write file

Present results clearly and offer to save generated config.
